Created: 2025-09-24

Challenge Type: #Web_App_Exploitation
Challenge Difficulty: #Hard 
Attachments: Leek Website

Leek
Description
***
Our favorite [grocery store](https://0d136b23f0ee5e9b8b58cf2865b02e23-leek.web.cityinthe.cloud/) allegedly has a vulnerability, can you replicate it?  
  
**Note: Your scope is limited to HTTPS. You may use automated tools that make educated guesses for this challenge, blind automated brute force is not permitted**

Questions
***
This is an interesting one. We are not given a whole lot of information and all the website looks like is a grocery list creator.

![[Leek-Website.png]]

 Since our scope is limited to HTTPS, we can rule out any command injection. If we try to take a look at robots.txt, we are given a 404 error. No leaked files this time around.
Next, lets look to the website source code to see if there is any code embedded in the website itself. You can look at the source code of a website by right clicking and selecting `view page source`. When looking through the html, we find a large amount of scripts, but one line that is interesting is:

```html
<script src="/static/app.js" defer="defer"></script>
```

This looks like the main control logic for our website app. We can also infer that this website is using node.js. You will see why this information in important in a minute. We try to access this code by plugging it into our search bar, and it looks like we can.

```node.js
function renderList(items) {
  const list = document.getElementById('list');
  const children = _.map(items, (item, index) => {
    const enc = new TextDecoder('utf-8');
    const decodedText = enc.decode(new Uint8Array(item.data));

    const child = document.createElement('div');
    child.className = 'ui item';
    child.style.display = 'flex';
    child.style.alignItems = 'baseline';
    child.innerHTML = `<button class="ui button" onClick="deleteItem(${index})">Delete</button><div class="content" style="padding-left: 10px"><h3 class="header">${decodedText}</h3></div>`;
    return child;
  });
  list.replaceChildren(...children);
}

function addItem(ev) {
  const item = document.getElementById('toadd');
  const { value } = item;
  superagent.post('/add')
    .send({ content : value })
    .then((res) => renderList(res.body))
  ev.preventDefault();
}

function deleteItem(item) {
  superagent.post('/delete')
    .send({ index : item })
    .then((res) => {
      renderList(res.body);
    });
}

function getCurrentList() {
  superagent
    .get('/list')
    .then((res) => {
      renderList(res.body);
    });
}

const form = document.getElementById('item');
form.addEventListener('submit', addItem);
getCurrentList()
```

Just at a glance, this code looks fine, and we can assume this code is running on the server. With this code in mind, we can interpret what happens if we send a request by adding an item.

![[Leek-Request-Response.png]]

Now if we look back at our code above, the sent type is a `String`. Nothing wrong with that. However, When we look at the response, we see something interesting. The return type is of type `Buffer`, not `String`. The script will take this buffer type and send it to the `renderList` function. We can assume there is a script on the backend that will instantiate this buffer type with something along the lines of

`new Buffer("Input")`

We can go to the Buffer documentation in node.js (that's why its important we find the exact language being used), and see a few interesting things about Buffer:

![[Leek-Buffer.png]]

Deprecated functions? Yes please.

We can see if the server will return some unintended information when we try to use some of the depreciated data types. Lets open up the site in [[Burpsuite]] and add an item to the list while the proxy intercept is on. Once we capture the request, lets send our POST request to our [[Repeater]] so we can edit the input on the fly.
(You can send a request to the Repeater module by right clicking it in the Proxy view and clicking the option `Send to Repeater`)

When you get to Repeater, here is what you should see:

![[Leek-Repeater.png]]

What we're interested in is the `content` field near the bottom. We want to edit this field to some of the depreciated fields that we found. I note below what each of my payloads looked like.

`Array`: `[cat, dog, goat]`
- The server didnt send a response, so we can ignore
`Buffer`: --
- We cant instantiate a buffer, nor do we have any known buffer types, so we can skip this
`size (int)`: 5
- We did get a response from this

![[Leek-Buffer Response.png]]

I can take those ASCII values from our response and decode it using cyber chef

![[Leek-Cyber Chef.png]]

Bingo! We got part of a flag. This means that by putting in an integer value, we instantiate a buffer that happens to have values from the server's memory. The reason this works is because when we send a numerical value through our POST request, we can deduce that the server is using the method `new Buffer(size)` which creates a null buffer with size `size`. The issue is, this function will instead instantiate a buffer with values stored on the server's memory as opposed to clearing that memory for a null buffer, allowing us to view bits of the memory. If we just increase the size of the buffer, we can reveal more of the flag. Since the flag is 13 characters long (including dashes), lets increase the size of our input to 13

![[Leek Full Buffer.png]]

Even more data! Delicious
Lets stick it into cyber chef:

![[Leek-CyberChef Flag.png]]

And there's our flag. Some would say the flag was on clearance :)

(Note: I found after doing this when you send a request using the repeater, you can just refresh the webpage to get the flag as well, skipping cyber chef.)

Q1
What is the flag?

Found after exploiting the website's buffer vulnerability.

