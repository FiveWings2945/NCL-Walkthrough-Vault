Created: 2025-09-25

Challenge Type: #Enumeration_and_Exploitation
Challenge Difficulty: #Easy
Attachments: Bytes.py

Bytes
Description
***
Determine the secret password that will validate successfully against the verify function. We've been having trouble getting it to run, but we saw it running properly on a different system. The code seems to be a bit old, maybe you can find the right environment/configuration to get it to run.

Questions
***
Q1 
What language is this program written in?

Simple enough. One look at it and you'll find its our favorite snake friend.

Q2
What is the password that will successfully pass the verify function?

When we look at our python code, we should look at two lines here: The verify function, and what it is verifying against:

```python
def verify(submission):
    processed = [ ]
    if len(submission) % 2 != 0:
        return False

    for i in range(0, len(submission) / 2):
        processed.append(int(submission[i * 2] + submission[(i * 2) + 1], 16))

    ekc = [ 0x53, 75, 0x59, 0x2D, 0110, 0x45, 88, 72, 0x2D, 0x35, 0x36, 0x38, 0x30 ]
    if len(processed) != len(ekc):
        return False

    for i in range(len(processed)):
        if ekc[i] != processed[i]:
            return False

    return True
```

And it looks like our input is being verified against:
`ekc = [ 0x53, 75, 0x59, 0x2D, 0110, 0x45, 88, 72, 0x2D, 0x35, 0x36, 0x38, 0x30 ]`

This looks like a mess of strings, but we can figure it out pretty easily
`ekc[0] = 0x53`: Hexadecimal. Denoted by the `0x` prefix
`ekc[1] = 75`: base 10 number. Pretty straightforward
`ekc[4] = 0110`: I would be inclined to believe that this is binary, as it is only one's and zeros, but something tells me otherwise. Looking at the python 2.7 documentation for data types, and **Octal** number can be denoted by one `0` as a prefix. So this is an octal `110`

Using these, we just need to build our input. The important line is how our input will be interpreted:
```python
for i in range(0, len(submission) / 2):
        processed.append(int(submission[i * 2] + submission[(i * 2) + 1], 16))
```

Our input will be taken as a string, and every other letter will be prepended to the next letter, interpreted as a base 16 number, and saved as an int. So we need to take each number in ekc and break it down into two hexadecimal digits. This means we need to translate each of ekc's numbers into hex.
##### Process
Hex numbers: Easy, just add them to our input as they are
Decimal numbers: Convert them into hex using a decimal to hex calculator
Octal numbers:  Convert them into hex using a octal to hex calculator

```
Ekc              →          Our input
0x53             →          53
75               →          4B
0x59             →          59
0x2D             →          2D
0110             →          48
0x45             →          45
88               →          58
72               →          48
0x2D             →          2D
0x35             →          35
0x36             →          36
0x38             →          38
0x30             →          30
```

Now we just string it all together to get our input.