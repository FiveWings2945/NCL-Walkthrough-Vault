Created: 2025-09-25

Challenge Type: #Enumeration_and_Exploitation 
Challenge Difficulty: #Hard 
Attachments: RE2_64bit

Binary2
Description
***
We need to break into a program that the hackers have created. You will need to provide the identifier, 4930, as the only argument to the program.

Questions
***
Its another binary, so we are gonna go ahead and open it up with Ghidra and analyze it. When we finish analyzing it, we get names for two interesting functions: `main` and `getflagbytid`. I have added the main function below with some variable renaming

```c
undefined8 main(int arcg,undefined8 *argv)

{
  size_t lengthOfInput;
  long lVar1;
  undefined1 local_48 [60];
  undefined4 local_c;
  
  if (arcg != 2) {
    printf("usage: %s <tid>\n",*argv);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  lengthOfInput = strlen((char *)argv[1]);
  if (lengthOfInput != 4) {
    printf("usage: %s <tid>\n",*argv);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  lVar1 = strtol((char *)argv[1],(char **)0x0,10);
  local_c = (undefined4)lVar1;
  printf("Please enter a password: ");
  __isoc99_scanf(&DAT_00400bbf,local_48);
  printf("Getting the flag from the program.");
  fflush(stdout);
  sleep(1);
  putchar(0x2e);
  fflush(stdout);
  sleep(1);
  putchar(0x2e);
  fflush(stdout);
  sleep(1);
  putchar(0x2e);
  fflush(stdout);
  sleep(1);
  puts(" password incorrect");
  return 0;
}
```

At first, this looks like your standard password checker program. However, you should look a little bit closer at the program. What's missing?

That's right, there is no checker logic! In fact, theres no call to `getflagbytid` either. That means there wont be a call to to retrieve the flag even if we get some magic password. So, unlike the first bytes challenge, we have to decode our flag.

Lets look at the `getflagbytid` function (I renamed some variables for readability)

```c
void getflagbytid(int tid)

{
  char local_18;
  char local_17;
  char local_16;
  char local_15;
  char local_14;
  char local_13;
  char local_12;
  char local_11;
  char local_10;
  
  memset(&local_18,0,0xe);
  local_18 = letterString[0x27];
  local_17 = letterString[0x1c];
  local_16 = letterString[0x25];
  local_15 = letterString[0x3e];
  local_14 = letterString[0x1f];
  local_13 = letterString[0x32];
  local_12 = letterString[0x28];
  local_11 = letterString[0x1f];
  local_10 = letterString[0x3e];
  printf("%s%c%c%c%c\n",&local_18,(ulong)(uint)(int)letterString[(tid + 0x8c) % 10 + 0x34],
         (ulong)(uint)(int)letterString[(tid + -0x1450) % 9 + 0x34],
         (ulong)(uint)(int)letterString[(tid * 10 + -0x78) % 8 + 0x34],
         (ulong)(uint)(int)letterString[(tid + 0x23f0) % 7 + 0x34]);
  return;
}
```

Looks like a lot of math to me. Frankly, I like math as much as the next guy, but lets let the calculator do it for us. We can make a python script to decode all of these for us

```python
flag = []
tid = 4930
letterString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-"
# Letters
flagInstructions = [0x27, 0x1c, 0x25, 0x3e, 0x1f, 0x32, 0x28, 0x1f, 0x3e]
flag.extend(letterString[i] for i in flagInstructions)

#Numbers
flag.extend(letterString[(tid + 0x8c) % 10 + 0x34])
flag.extend(letterString[(tid + -0x1450) % 9 + 0x34])
flag.extend(letterString[(tid * 10 + -0x78) % 8 + 0x34])
flag.extend(letterString[(tid + 0x23f0) % 7 + 0x34])
print(flag[i] for i in flag)
```


Q1
What is the flag hidden in the program?

We can run our python program this to get our flag.