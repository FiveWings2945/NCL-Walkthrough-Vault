Created: 2025-09-24

Challenge Type: #Enumeration_and_Exploitation 
Challenge Difficulty: #Medium
Attachments: RE1_64bit

Binary1
Description
***
We need to break into a program that the hackers have created. You will need to provide the identifier, 7074, as the only argument to the program.

Questions
***
(*Note: My decompiler of choice is Ghidra, but there is a large number of decompilers out there, so don't feel restricted. I use Ghidra because of the functionality and view that it provides.*)

First with RE binaries, we can run it and see what output we get. We will need to use 7074 as our argument, since that is in our description as to what to use.
```sh
┌──(kali㉿kali)-[~/Downloads]
└─$ ./RE1_64bit 7074 
Please enter a password: Test
Try again.
```
Looks like your standard password checker. Lets open this binary up in Ghidra then.

Since this is a binary executable, we will be opening it up in our decompiler of choice. In my case, I will be using Ghidra. Ill import the binary, open it in the decompiler, and analyze it.

When its done analyzing, we find our main function:
```c
undefined8 main(int param_1,undefined8 *param_2)

{
  size_t sVar1;
  char local_38 [44];
  int local_c;
  
  if (param_1 != 2) {
    printf("usage: %s <tid>\n",*param_2);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  sVar1 = strlen((char *)param_2[1]);
  if (sVar1 != 4) {
    printf("usage: %s <tid>\n",*param_2);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  local_c = 0;
  printf("Please enter a password: ");
  gets(local_38);
  if (local_c == 0) {
    puts("Try again.");
  }
  else {
    fg(param_2);
  }
  return 0;
}
```

A lot of this looks like gibberish and unreadable, as it is just autodefined variables, so let me go and rename a few of these:
```c
undefined8 main(int arg_c,undefined8 *arg_v)

{
  size_t tid;
  char UserIn [44];
  int EmptyBuffer;
  
  if (arg_c != 2) {
    printf("usage: %s <tid>\n",*arg_v);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  tid = strlen((char *)arg_v[1]);
  if (tid != 4) {
    printf("usage: %s <tid>\n",*arg_v);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  EmptyBuffer = 0;
  printf("Please enter a password: ");
  gets(UserIn);
  if (EmptyBuffer == 0) {
    puts("Try again.");
  }
  else {
    fg(arg_v);
  }
  return 0;
}
```

(I renamed one of the variables to something that can help you before you finish this walkthrough. Can you find it?)

Now that the variables look better, lets look at what the program does:


```pseudo
Instantiate variables
Argument Check
User Input
Check if EmptyBuffer is 0
Else run fg(tid) //Flag Function
```
(Note: There are two ways to complete this challenge: Decrypting the values in the fg() function, or figuring out how to set EmptyBuffer to something other than 0. I will show how to do both.)

##### fg()
We can take a look at our fg() function:
```c
void fg(long param_1)

{
  long lVar1;
  char local_28;
  char local_27;
  char local_26;
  char local_25;
  char local_24;
  char local_23;
  char local_22;
  char local_21;
  char local_20;
  char local_1f;
  char local_1e;
  char local_1d;
  char local_1c;
  uint local_c;
  
  lVar1 = strtol(*(char **)(param_1 + 8),(char **)0x0,10);
  local_c = (uint)lVar1;
  memset(&local_28,0,0xe);
  local_28 = cs.2857[0x27];
  local_27 = cs.2857[0x1c];
  local_26 = cs.2857[0x25];
  local_25 = cs.2857[0x3e];
  local_24 = cs.2857[0x1e];
  local_23 = cs.2857[0x33];
  local_22 = cs.2857[0x28];
  local_21 = cs.2857[0x1f];
  local_20 = cs.2857[0x3e];
  local_1f = cs.2857[(int)local_c % 10 + 0x34];
  local_1e = cs.2857[(int)local_c % 9 + 0x34];
  local_1d = cs.2857[(int)local_c % 8 + 0x34];
  local_1c = cs.2857[(int)local_c % 7 + 0x34];
  printf("your tid: %d\n",(ulong)local_c);
  puts(&local_28);
  return;
}
```
This is a very long and convoluted decryption function. The important piece of this decryption function is the variable `cs.2857`. This is a string variable we find in memory
`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-`
At first you may think the instructions above would be hex, but it is actually just referencing the positions in the string. The last 4 lines will take that tid we provided and get the index with modulo our tid + 0x34. 
We can create a python script to do all of this for us:

```python
inString = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-'

flag = []
flagInstructions = [0x27, 0x1c, 0x25, 0x3e, 0x1e, 0x33, 0x28, 0x1f, 0x3e]
flagInstructions.append((7074 % 10) + 0x34)
flagInstructions.append((7074 % 9) + 0x34)
flagInstructions.append((7074 % 8) + 0x34)
flagInstructions.append((7074 % 7) + 0x34)
flag = [inString[i] for i in flagInstructions]
print(flag)
```

This will print the flag we need
##### EmptyBuffer
Looking at the code, we come to find that there is no logic that verifies a password. So no matter what your input will be, the fg() code will never run. However, maybe there is a way around this. The thing that sets off alarm bells is the gets() function. This function has a very long history of a vulnerability called Buffer Overflow. This means you can "overflow" a variable by overwriting its memory through input. This is made even more obvious as the UserIn variable is a c-string with size 44 bytes. This means that the variable will be written in memory as 44 bytes, and then the next variable will be written to memory.

In the case of our program, the variable directly after UserIn is emptybuffer which is the variable we need to overwrite. So, we can just create a user input that is more than 44 bytes and overwrite the EmptyBuffer variable, as its storage in memory is directly after UserIn. Lets try it:

```bash
┌──(kali㉿kali)-[~/Downloads]
└─$ ./RE1_64bit 7074
Please enter a password: 11111111111111111111111111111111111111111111111111
your tid: 7074
--FLAG--

```

Bingo, we got our Flag
