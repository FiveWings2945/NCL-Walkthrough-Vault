Created: 2025-09-24

Challenge Type: #Enumeration_and_Exploitation
Challenge Difficulty: #Easy
Attachments: Python1.py

Python1
Description
***
We have created a python script for you to break into as training. See if you can figure out a password that will authenticate with the program

Questions
***
Q1
What is an input to this program that will result in a correct validation?

Generally, when we approach reverse engineering problems, they will contain password validation problems such as this. There are two methods for completing these problems: automated or manual. Its really up to you how you will approach a given problem on a case-by-case basis. 

For this program, we are looking at a password validation function with a couple of parameters. Lets break it down:
```python
#Python1.py
def main():
  if len(sys.argv) != 2:  # Program call with only 2 args
    print("Invalid args")
    return
  password = sys.argv[1]
  builder = 0
  for c in password:
    builder += ord(c) # Get the ASCII value of each char in password
  if builder == 1000 and len(password) == 10 and ord(password[1]) == 83: 
  # 1) ASCII values must equal 1000 
  # 2) The password must be 10 characters long
  # 3) The second letter ASCII value must be 83. Letter S
    print("correct")
  else:
    print("incorrect")
```

The important line, as we can see, is 
`if builder == 1000 and len(password) == 10 and ord(password[1]) == 83:`
1) ASCII values must equal 1000 
2) The password must be 10 characters long
3) The second letter ASCII value must be 83. Letter S

We can do this through manual means fairly easily, but I did prompt ChatGPT to give me a z3 script (python solver library) to solve it too.

#### Manual
Lets start with the third condition
3) The second letter ASCII value must be 83. Letter S
  Easy. `password[1] = 'S'`
  
Now lets look at the other two:
1) ASCII values must equal 1000 
2) The password must be 10 characters long
This is fairly simple math. All we have to do is solve the following equation. Since S = 83, and the max the string can be is 1000, we can show:
$$
1000 = 9x -83
$$
Where x is the ascii value of a character.
We can simplify this into:
$$
917=9x
$$
Not a very neat number. What we can do is find numbers divisible by 8 that are close to 917, and subtract a value to make the big number divisible by 8. One number we can use is 848. That means our first character will be 917 - 848. This will be the letter for 69, aka `E`. This makes our equation:
$$
\begin{align}
1000 &= 8x -83 -69
\\848 &= 8x
\\106 &= x 
\end{align}
$$
The ASCII representation of 106 is `j`. From this knowledge, we can build a valid password.

#### Automatic
ChatGPT gave me this script, which does work really well
```python
from z3 import *

def crack():
    length = 10
    target_sum = 1000
    # Create 10 symbolic characters
    chars = [Int(f"c{i}") for i in range(length)]
    s = Solver()
    # ASCII range constraint
    for c in chars:
        s.add(c >= 32, c <= 126)  # printable range
    # Sum constraint
    s.add(Sum(chars) == target_sum)
    # Length fixed
    # (implicit since we made 10 vars)
    # Second character must be 'S'
    s.add(chars[1] == ord('S'))
    if s.check() == sat:
        model = s.model()
        password = ''.join(chr(model[c].as_long()) for c in chars)
        print("Found:", password)
    else:
        print("No solution")

if __name__ == "__main__":
    crack()
```

This will generate the password we need based on certain constraints that we have set. For example, `chars = [Int(f"c{i}") for i in range(length)]` creates a list of length 10, `for c in chars: s.add(c >= 32, c <= 126)`  will only ensure we have printable characters, `s.add(Sum(chars) == target_sum)` will make sure the characters ASCII sum to 1000, and `s.add(chars[1] == ord('S'))` will note that the 1st char is `S`.

For me I wouldn't spend that long developing a script, as it would take the same amount of time to do it manually, but if you really want to practice RE scripting, this is a good simple puzzle to do it.